<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Bridge</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f7;
        }
        h1 {
            color: #333;
        }
        textarea {
            width: 100%;
            max-width: 500px;
            height: 150px;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 16px;
            resize: vertical;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            color: #fff;
            background-color: #007aff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            max-width: 500px;
        }
        button:hover {
            background-color: #005bb5;
        }
        #status {
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        }
        #streamSection {
            width: 100%;
            max-width: 900px;
            margin-top: 24px;
            padding: 16px;
            border: 1px solid #ddd;
            border-radius: 12px;
            background: #fff;
            box-sizing: border-box;
        }
        #streamSection h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #333;
        }
        #streamControls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        #streamControls button {
            max-width: none;
            width: auto;
            flex: 1;
        }
        #toggleStreamBtn {
            background-color: #111827;
            margin: 0;
        }
        #toggleStreamBtn:hover {
            background-color: #0b1220;
        }
        #fullscreenStreamBtn {
            background-color: #4b5563;
            margin: 0;
        }
        #fullscreenStreamBtn:hover {
            background-color: #374151;
        }
        #fullscreenStreamBtn:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        #windowPickerRow {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        #windowSelect {
            flex: 1;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 14px;
            min-width: 0;
        }
        #refreshWindowsBtn {
            background-color: #4b5563;
            max-width: none;
            width: auto;
            flex: 0 0 auto;
            margin: 0;
        }
        #refreshWindowsBtn:hover {
            background-color: #374151;
        }
        #streamStatus {
            font-size: 13px;
            color: #555;
            margin-bottom: 10px;
        }
        #streamFrame {
            display: none;
            width: 100%;
            border-radius: 10px;
            border: 1px solid #d1d5db;
            background: #000;
        }
    </style>
</head>
<body>
    <h1>Claude Bridge</h1>
    <textarea id="messageInput" placeholder="Type your message for Claude..."></textarea>
    <button id="sendBtn">Send to Mac</button>
    <div id="status"></div>
    <div id="streamSection">
        <h2>Claude Live View</h2>
        <div id="streamControls">
            <button id="toggleStreamBtn">Start Live View</button>
            <button id="fullscreenStreamBtn" disabled>Full Screen</button>
        </div>
        <div id="windowPickerRow">
            <select id="windowSelect">
                <option value="">Auto (Claude window)</option>
            </select>
            <button id="refreshWindowsBtn">Refresh Windows</button>
        </div>
        <div id="streamStatus">Live view is off.</div>
        <img id="streamFrame" alt="Claude live stream preview">
    </div>

    <script>
        const sendBtn = document.getElementById('sendBtn');
        const messageInput = document.getElementById('messageInput');
        const statusDiv = document.getElementById('status');
        const toggleStreamBtn = document.getElementById('toggleStreamBtn');
        const fullscreenStreamBtn = document.getElementById('fullscreenStreamBtn');
        const refreshWindowsBtn = document.getElementById('refreshWindowsBtn');
        const windowSelect = document.getElementById('windowSelect');
        const streamStatusDiv = document.getElementById('streamStatus');
        const streamFrame = document.getElementById('streamFrame');
        let doneDelayMs = 2000;
        let streamIntervalMs = 1000;
        let fallbackTimer = null;
        let streamRefreshTimer = null;
        let streamEnabled = false;
        let currentStreamMode = 'screen';
        let selectedWindow = null;

        function markDoneFromUiFallback() {
            statusDiv.textContent = "Done — check Claude app";
            sendBtn.disabled = false;
        }

        function getFullscreenElement() {
            return document.fullscreenElement || document.webkitFullscreenElement || null;
        }

        function updateFullscreenButtonLabel() {
            fullscreenStreamBtn.textContent = getFullscreenElement() ? 'Exit Full Screen' : 'Full Screen';
        }

        function modeToLabel(mode) {
            if (mode === 'selected-window') return 'Selected window';
            if (mode === 'claude-window' || mode === 'window') return 'Claude window';
            return 'Screen fallback';
        }

        function selectedWindowToLabel(windowInfo) {
            if (!windowInfo) return 'Auto (Claude window)';
            if (windowInfo.title) {
                return `${windowInfo.appName} — ${windowInfo.title}`;
            }
            return windowInfo.appName || `Window #${windowInfo.id}`;
        }

        function updateStreamStatusText() {
            const modeText = modeToLabel(currentStreamMode);
            const targetText = selectedWindowToLabel(selectedWindow);
            if (streamEnabled) {
                streamStatusDiv.textContent = `Live view is on (${modeText}). Target: ${targetText}.`;
                return;
            }
            streamStatusDiv.textContent = `Live view is off. Target: ${targetText}.`;
        }

        async function enterStreamFullscreen() {
            if (streamFrame.requestFullscreen) {
                await streamFrame.requestFullscreen();
                return;
            }
            if (streamFrame.webkitRequestFullscreen) {
                streamFrame.webkitRequestFullscreen();
                return;
            }
            throw new Error('Fullscreen not supported on this browser');
        }

        async function exitStreamFullscreen() {
            if (document.exitFullscreen && document.fullscreenElement) {
                await document.exitFullscreen();
                return;
            }
            if (document.webkitExitFullscreen && document.webkitFullscreenElement) {
                document.webkitExitFullscreen();
            }
        }

        function setStreamUiState(running, mode, selectedWindowOverride) {
            streamEnabled = running;
            if (mode) {
                currentStreamMode = mode;
            }
            if (typeof selectedWindowOverride !== 'undefined') {
                selectedWindow = selectedWindowOverride;
            }

            toggleStreamBtn.textContent = running ? 'Stop Live View' : 'Start Live View';
            fullscreenStreamBtn.disabled = !running;

            if (running) {
                streamFrame.style.display = 'block';
            } else {
                exitStreamFullscreen().catch(() => {});
                streamFrame.style.display = 'none';
                streamFrame.removeAttribute('src');
                updateFullscreenButtonLabel();
            }

            updateStreamStatusText();
        }

        function refreshStreamFrame() {
            if (!streamEnabled) return;
            streamFrame.src = `/stream/frame?ts=${Date.now()}`;
        }

        function startFrameTimer() {
            if (streamRefreshTimer) {
                clearInterval(streamRefreshTimer);
            }
            streamRefreshTimer = setInterval(refreshStreamFrame, streamIntervalMs);
        }

        function populateWindowSelect(windows, selectedWindowId) {
            windowSelect.innerHTML = '';

            const autoOption = document.createElement('option');
            autoOption.value = '';
            autoOption.textContent = 'Auto (Claude window)';
            windowSelect.appendChild(autoOption);

            windows.forEach((windowInfo) => {
                const option = document.createElement('option');
                option.value = String(windowInfo.id);
                const label = windowInfo.title
                    ? `${windowInfo.appName} — ${windowInfo.title}`
                    : windowInfo.appName;
                option.textContent = `${label} (#${windowInfo.id})`;
                windowSelect.appendChild(option);
            });

            if (selectedWindowId) {
                windowSelect.value = String(selectedWindowId);
            } else {
                windowSelect.value = '';
            }
        }

        async function loadWindowOptions() {
            const response = await fetch('/stream/windows');
            if (!response.ok) {
                throw new Error('Failed to load windows');
            }

            const payload = await response.json();
            const windows = Array.isArray(payload.windows) ? payload.windows : [];
            const selectedWindowId = payload.selectedWindowId || null;
            populateWindowSelect(windows, selectedWindowId);

            if (selectedWindowId) {
                selectedWindow = windows.find((item) => item.id === selectedWindowId) || null;
            } else {
                selectedWindow = null;
            }
            updateStreamStatusText();
        }

        async function setWindowSelection(windowId) {
            const response = await fetch('/stream/select-window', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ windowId })
            });

            if (!response.ok) {
                let message = 'Failed to select window';
                try {
                    const errorPayload = await response.json();
                    if (errorPayload && errorPayload.error) {
                        message = errorPayload.error;
                    }
                } catch {
                    // Ignore JSON parsing error.
                }
                throw new Error(message);
            }

            const payload = await response.json();
            setStreamUiState(Boolean(payload.running), payload.mode, payload.selectedWindow || null);
            refreshStreamFrame();
        }

        async function startStream() {
            const response = await fetch('/stream/start', { method: 'POST' });
            if (!response.ok) {
                throw new Error('Failed to start stream');
            }
            const payload = await response.json();
            setStreamUiState(true, payload.mode, payload.selectedWindow || null);
            refreshStreamFrame();
            startFrameTimer();
        }

        async function stopStream() {
            const response = await fetch('/stream/stop', { method: 'POST' });
            if (!response.ok) {
                throw new Error('Failed to stop stream');
            }
            const payload = await response.json();
            if (streamRefreshTimer) {
                clearInterval(streamRefreshTimer);
                streamRefreshTimer = null;
            }
            setStreamUiState(false, payload.mode, payload.selectedWindow || null);
        }

        async function initStreamStatus() {
            try {
                const response = await fetch('/stream/status');
                if (!response.ok) return;
                const status = await response.json();
                setStreamUiState(Boolean(status.running), status.mode, status.selectedWindow || null);
                await loadWindowOptions();
                if (status.running) {
                    refreshStreamFrame();
                    startFrameTimer();
                }
            } catch (error) {
                console.error('Error loading stream status:', error);
            }
        }

        toggleStreamBtn.addEventListener('click', async () => {
            toggleStreamBtn.disabled = true;
            try {
                if (streamEnabled) {
                    await stopStream();
                } else {
                    await startStream();
                }
            } catch (error) {
                console.error('Error toggling stream:', error);
                streamStatusDiv.textContent = 'Unable to toggle live view.';
            } finally {
                toggleStreamBtn.disabled = false;
            }
        });

        fullscreenStreamBtn.addEventListener('click', async () => {
            if (fullscreenStreamBtn.disabled) return;
            fullscreenStreamBtn.disabled = true;
            try {
                if (getFullscreenElement()) {
                    await exitStreamFullscreen();
                } else {
                    await enterStreamFullscreen();
                }
                updateFullscreenButtonLabel();
            } catch (error) {
                console.error('Error toggling fullscreen:', error);
                streamStatusDiv.textContent = 'Fullscreen is not supported on this browser.';
            } finally {
                fullscreenStreamBtn.disabled = !streamEnabled;
            }
        });

        refreshWindowsBtn.addEventListener('click', async () => {
            refreshWindowsBtn.disabled = true;
            windowSelect.disabled = true;
            try {
                await loadWindowOptions();
            } catch (error) {
                console.error('Error refreshing windows:', error);
                streamStatusDiv.textContent = 'Unable to refresh window list.';
            } finally {
                refreshWindowsBtn.disabled = false;
                windowSelect.disabled = false;
            }
        });

        windowSelect.addEventListener('change', async () => {
            const rawValue = windowSelect.value;
            const windowId = rawValue ? Number(rawValue) : null;

            windowSelect.disabled = true;
            refreshWindowsBtn.disabled = true;
            try {
                await setWindowSelection(windowId);
            } catch (error) {
                console.error('Error selecting stream window:', error);
                streamStatusDiv.textContent = `Unable to select window: ${error.message}`;
                await loadWindowOptions();
            } finally {
                windowSelect.disabled = false;
                refreshWindowsBtn.disabled = false;
            }
        });

        document.addEventListener('fullscreenchange', updateFullscreenButtonLabel);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButtonLabel);

        sendBtn.addEventListener('click', async () => {
            const message = messageInput.value.trim();
            if (!message) return;

            statusDiv.textContent = "Sending...";
            sendBtn.disabled = true;

            try {
                const response = await fetch('/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });

                if (response.ok) {
                    statusDiv.textContent = "Sent! Waiting for Claude...";
                    messageInput.value = '';
                    if (fallbackTimer) {
                        clearTimeout(fallbackTimer);
                    }
                    // Fallback for missed SSE events from ntfy.
                    fallbackTimer = setTimeout(markDoneFromUiFallback, doneDelayMs + 1500);
                } else {
                    statusDiv.textContent = "Failed to send message.";
                    sendBtn.disabled = false;
                }
            } catch (error) {
                console.error("Error sending message:", error);
                statusDiv.textContent = "Error sending message.";
                sendBtn.disabled = false;
            }
        });

        // Fetch configuration from the server to get the NTFY_TOPIC
        fetch('/config')
            .then(res => res.json())
            .then(config => {
                const NTFY_TOPIC = config.ntfyTopic;
                doneDelayMs = Number(config.doneDelayMs) || 2000;
                streamIntervalMs = Number(config.streamIntervalMs) || 1000;
                const eventSource = new EventSource(`https://ntfy.sh/${NTFY_TOPIC}/sse`);
                eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.event === 'message' && data.message.includes('responded')) {
                        if (fallbackTimer) {
                            clearTimeout(fallbackTimer);
                        }
                        statusDiv.textContent = "Done — check Claude app";
                        sendBtn.disabled = false;
                    }
                };
                initStreamStatus();
            })
            .catch(err => console.error("Error fetching config:", err));
    </script>
</body>
</html>
