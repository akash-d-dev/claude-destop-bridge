<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <title>Claude Bridge</title>
    <style>
        html {
            background: #000;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 8px 16px 18px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            color: #f5f5f5;
            color-scheme: dark;
        }
        h1 {
            color: #f5f5f5;
            margin: 2px 0 8px 0;
        }
        #commandSection {
            width: 100%;
            max-width: 500px;
            margin-bottom: 8px;
        }
        #commandControls {
            display: flex;
            gap: 10px;
            margin-bottom: 6px;
        }
        #commandSelect {
            flex: 1;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 14px;
            min-width: 0;
            background: #000;
            color: #f5f5f5;
        }
        #sendCommandBtn {
            background-color: #121212;
            border-color: #2a2a2a;
            max-width: none;
            width: auto;
            flex: 0 0 auto;
            margin: 0;
        }
        #sendCommandBtn:hover {
            background-color: #1a1a1a;
        }
        #sendCommandBtn:disabled {
            background-color: #0d0d0d;
            color: #6b7280;
            border-color: #1d1d1d;
            cursor: not-allowed;
        }
        #commandHint {
            font-size: 12px;
            color: #9ca3af;
        }
        textarea {
            width: 100%;
            max-width: 500px;
            height: 150px;
            padding: 10px;
            margin-bottom: 12px;
            border: 1px solid #262626;
            border-radius: 8px;
            font-size: 16px;
            resize: vertical;
            background: #000;
            color: #f5f5f5;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            color: #f5f5f5;
            background-color: #121212;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            max-width: 500px;
        }
        button:hover {
            background-color: #1a1a1a;
        }
        #status {
            width: 100%;
            max-width: 500px;
            margin: 8px 0 10px 0;
            font-size: 14px;
            color: #9ca3af;
        }
        #streamSection {
            width: 100%;
            max-width: 900px;
            margin-top: 12px;
            padding: 14px;
            border: 1px solid #262626;
            border-radius: 12px;
            background: #000;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #streamSection h2 {
            margin: 0 0 2px 0;
            font-size: 18px;
            color: #f5f5f5;
        }
        #streamControls {
            display: flex;
            gap: 10px;
            margin: 0;
        }
        #streamControls button {
            max-width: none;
            width: auto;
            flex: 1;
        }
        #toggleStreamBtn {
            background-color: #121212;
            border-color: #2a2a2a;
            margin: 0;
        }
        #toggleStreamBtn:hover {
            background-color: #1a1a1a;
        }
        #fullscreenStreamBtn {
            background-color: #121212;
            border-color: #2a2a2a;
            margin: 0;
        }
        #fullscreenStreamBtn:hover {
            background-color: #1a1a1a;
        }
        #fullscreenStreamBtn:disabled {
            background-color: #0d0d0d;
            color: #6b7280;
            border-color: #1d1d1d;
            cursor: not-allowed;
        }
        #windowPickerRow {
            display: flex;
            gap: 10px;
            margin: 0;
        }
        #displayPickerRow {
            display: flex;
            gap: 10px;
            margin: 0;
        }
        #windowSelect {
            flex: 1;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 14px;
            min-width: 0;
            background: #000;
            color: #f5f5f5;
        }
        #displaySelect {
            flex: 1;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 14px;
            min-width: 0;
            background: #000;
            color: #f5f5f5;
        }
        #refreshWindowsBtn {
            background-color: #121212;
            border-color: #2a2a2a;
            max-width: none;
            width: auto;
            flex: 0 0 auto;
            margin: 0;
        }
        #refreshWindowsBtn:hover {
            background-color: #1a1a1a;
        }
        #refreshDisplaysBtn {
            background-color: #121212;
            border-color: #2a2a2a;
            max-width: none;
            width: auto;
            flex: 0 0 auto;
            margin: 0;
        }
        #refreshDisplaysBtn:hover {
            background-color: #1a1a1a;
        }
        #streamStatus {
            font-size: 13px;
            color: #9ca3af;
            margin: 0;
        }
        #streamFrame {
            display: none;
            width: 100%;
            max-height: 62vh;
            object-fit: contain;
            border-radius: 10px;
            border: 1px solid #262626;
            background: #000;
        }
        #authOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 16px;
            box-sizing: border-box;
        }
        #authCard {
            width: 100%;
            max-width: 420px;
            background: #000;
            border-radius: 12px;
            border: 1px solid #262626;
            box-sizing: border-box;
            padding: 18px;
        }
        #authCard h2 {
            margin: 0 0 8px 0;
            font-size: 20px;
            color: #f5f5f5;
        }
        #authSubtext {
            margin: 0 0 12px 0;
            color: #9ca3af;
            font-size: 14px;
        }
        #passcodeInput {
            width: 100%;
            box-sizing: border-box;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 12px;
            font-size: 16px;
            margin-bottom: 10px;
            background: #000;
            color: #f5f5f5;
        }
        #unlockBtn {
            max-width: none;
            margin: 0;
        }
        #authError {
            margin-top: 10px;
            min-height: 18px;
            font-size: 13px;
            color: #b91c1c;
        }
        textarea::placeholder,
        #passcodeInput::placeholder {
            color: #6b7280;
        }
        @media (max-width: 640px) {
            body {
                padding: 8px 12px 14px;
            }
            #commandControls,
            #streamControls,
            #windowPickerRow,
            #displayPickerRow {
                flex-direction: column;
            }
            #streamControls button {
                width: 100%;
                max-width: none;
            }
            #sendCommandBtn,
            #refreshWindowsBtn,
            #refreshDisplaysBtn {
                width: 100%;
                max-width: none;
            }
            #streamFrame {
                max-height: 52vh;
            }
        }
    </style>
</head>
<body>
    <div id="authOverlay">
        <div id="authCard">
            <h2>Unlock Claude Bridge</h2>
            <p id="authSubtext">Enter passcode to grant this device access for 24 hours.</p>
            <input id="passcodeInput" type="password" placeholder="Enter passcode" autocomplete="current-password">
            <button id="unlockBtn">Unlock</button>
            <div id="authError"></div>
        </div>
    </div>
    <!-- <h3>Claude Bridge</h3> -->
    <textarea id="messageInput" placeholder="Type your message for Claude..."></textarea>
    <button id="sendBtn">Send to Mac</button>
    <div id="status"></div>
    <div id="commandSection">
        <div id="commandControls">
            <select id="commandSelect">
                <option value="">Select command (optional)</option>
            </select>
            <button id="sendCommandBtn" disabled>Send Command</button>
        </div>
        <div id="commandHint">Pick a command and send instantly, no typing needed.</div>
    </div>
    <div id="streamSection">
        <!-- <h2>Claude Live View</h2> -->
        <img id="streamFrame" alt="Claude live stream preview">
        <div id="streamStatus">Live view is off.</div>
        <div id="streamControls">
            <button id="toggleStreamBtn">Start Live View</button>
            <button id="fullscreenStreamBtn" disabled>Full Screen</button>
        </div>
        <div id="windowPickerRow">
            <select id="windowSelect">
                <option value="">Auto (Claude window)</option>
            </select>
            <button id="refreshWindowsBtn">Refresh Windows</button>
        </div>
        <div id="displayPickerRow">
            <select id="displaySelect">
                <option value="">Auto (All displays)</option>
            </select>
            <button id="refreshDisplaysBtn">Refresh Displays</button>
        </div>
    </div>

    <script>
        const sendBtn = document.getElementById('sendBtn');
        const messageInput = document.getElementById('messageInput');
        const commandSelect = document.getElementById('commandSelect');
        const sendCommandBtn = document.getElementById('sendCommandBtn');
        const commandHint = document.getElementById('commandHint');
        const statusDiv = document.getElementById('status');
        const toggleStreamBtn = document.getElementById('toggleStreamBtn');
        const fullscreenStreamBtn = document.getElementById('fullscreenStreamBtn');
        const refreshWindowsBtn = document.getElementById('refreshWindowsBtn');
        const refreshDisplaysBtn = document.getElementById('refreshDisplaysBtn');
        const windowSelect = document.getElementById('windowSelect');
        const displaySelect = document.getElementById('displaySelect');
        const streamStatusDiv = document.getElementById('streamStatus');
        const streamFrame = document.getElementById('streamFrame');
        const authOverlay = document.getElementById('authOverlay');
        const authSubtext = document.getElementById('authSubtext');
        const authError = document.getElementById('authError');
        const passcodeInput = document.getElementById('passcodeInput');
        const unlockBtn = document.getElementById('unlockBtn');

        let doneDelayMs = 2000;
        let streamIntervalMs = 1000;
        let sessionTtlMs = 24 * 60 * 60 * 1000;
        let fallbackTimer = null;
        let streamRefreshTimer = null;
        let streamEnabled = false;
        let authLocked = true;
        let commandOptions = [];
        let currentStreamMode = 'screen';
        let selectedWindow = null;
        let selectedDisplay = null;
        let noWindowsDetected = false;
        let noDisplaysDetected = false;
        let ntfyEventSource = null;

        function formatHours(ms) {
            const hours = Math.max(1, Math.round(ms / (60 * 60 * 1000)));
            return `${hours} hour${hours === 1 ? '' : 's'}`;
        }

        function setAuthSubtext() {
            authSubtext.textContent = `Enter passcode to grant this device access for ${formatHours(sessionTtlMs)}.`;
        }

        function setUiLocked(locked) {
            authLocked = locked;
            messageInput.disabled = locked;
            sendBtn.disabled = locked;
            commandSelect.disabled = locked;
            sendCommandBtn.disabled = locked || !commandSelect.value;
            toggleStreamBtn.disabled = locked;
            fullscreenStreamBtn.disabled = locked || !streamEnabled;
            windowSelect.disabled = locked;
            displaySelect.disabled = locked;
            refreshWindowsBtn.disabled = locked;
            refreshDisplaysBtn.disabled = locked;
        }

        function showAuth(message) {
            setUiLocked(true);
            authOverlay.style.display = 'flex';
            authError.textContent = message || '';
            passcodeInput.focus();
        }

        function hideAuth() {
            authOverlay.style.display = 'none';
            authError.textContent = '';
            setUiLocked(false);
        }

        function markDoneFromUiFallback() {
            statusDiv.textContent = "Done — check Claude app";
            sendBtn.disabled = authLocked;
        }

        function updateSendCommandState() {
            sendCommandBtn.disabled = authLocked || !commandSelect.value;
        }

        function populateCommandOptions(options) {
            commandOptions = Array.isArray(options) ? options : [];
            commandSelect.innerHTML = '';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select command (optional)';
            commandSelect.appendChild(defaultOption);

            commandOptions.forEach((item) => {
                const key = String(item.key || '').trim();
                if (!key) return;
                const label = String(item.description || key).trim();
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${key} — ${label}`;
                commandSelect.appendChild(option);
            });

            commandHint.textContent = commandOptions.length > 0
                ? `Pick a command and send instantly, no typing needed. (${commandOptions.length} available)`
                : 'No commands available from server.';

            updateSendCommandState();
        }

        function getFullscreenElement() {
            return document.fullscreenElement || document.webkitFullscreenElement || null;
        }

        function updateFullscreenButtonLabel() {
            fullscreenStreamBtn.textContent = getFullscreenElement() ? 'Exit Full Screen' : 'Full Screen';
        }

        function modeToLabel(mode) {
            if (mode === 'selected-window') return 'Selected window';
            if (mode === 'selected-display') return 'Selected display';
            if (mode === 'claude-window' || mode === 'window') return 'Claude window';
            return 'Screen fallback';
        }

        function selectedWindowToLabel(windowInfo) {
            if (!windowInfo) return 'Auto (Claude window)';
            if (windowInfo.title) {
                return `${windowInfo.appName} — ${windowInfo.title}`;
            }
            return windowInfo.appName || `Window #${windowInfo.id}`;
        }

        function selectedDisplayToLabel(displayInfo) {
            if (!displayInfo) return 'Auto (All displays)';
            const mainTag = displayInfo.isMain ? 'Main' : 'Secondary';
            return `${mainTag} display ${displayInfo.width}x${displayInfo.height} @ (${displayInfo.x}, ${displayInfo.y})`;
        }

        function updateStreamStatusText() {
            const modeText = modeToLabel(currentStreamMode);
            const windowTargetText = selectedWindowToLabel(selectedWindow);
            const displayTargetText = selectedDisplayToLabel(selectedDisplay);
            const noWindowsHint = noWindowsDetected
                ? ' No windows detected yet. Grant Screen Recording permission to your terminal/Node process, then click Refresh Windows.'
                : '';
            const noDisplaysHint = noDisplaysDetected
                ? ' No displays detected yet. Click Refresh Displays.'
                : '';
            const targetSummary = `Window target: ${windowTargetText}. Display target: ${displayTargetText}.`;
            if (streamEnabled) {
                streamStatusDiv.textContent = `Live view is on (${modeText}). ${targetSummary}${noWindowsHint}${noDisplaysHint}`;
                return;
            }
            streamStatusDiv.textContent = `Live view is off. ${targetSummary}${noWindowsHint}${noDisplaysHint}`;
        }

        async function enterStreamFullscreen() {
            if (streamFrame.requestFullscreen) {
                await streamFrame.requestFullscreen();
                return;
            }
            if (streamFrame.webkitRequestFullscreen) {
                streamFrame.webkitRequestFullscreen();
                return;
            }
            throw new Error('Fullscreen not supported on this browser');
        }

        async function exitStreamFullscreen() {
            if (document.exitFullscreen && document.fullscreenElement) {
                await document.exitFullscreen();
                return;
            }
            if (document.webkitExitFullscreen && document.webkitFullscreenElement) {
                document.webkitExitFullscreen();
            }
        }

        function setStreamUiState(running, mode, selectedWindowOverride, selectedDisplayOverride) {
            streamEnabled = running;
            if (mode) {
                currentStreamMode = mode;
            }
            if (typeof selectedWindowOverride !== 'undefined') {
                selectedWindow = selectedWindowOverride;
            }
            if (typeof selectedDisplayOverride !== 'undefined') {
                selectedDisplay = selectedDisplayOverride;
            }

            toggleStreamBtn.textContent = running ? 'Stop Live View' : 'Start Live View';
            fullscreenStreamBtn.disabled = authLocked || !running;

            if (running) {
                streamFrame.style.display = 'block';
            } else {
                exitStreamFullscreen().catch(() => {});
                streamFrame.style.display = 'none';
                streamFrame.removeAttribute('src');
                updateFullscreenButtonLabel();
            }

            updateStreamStatusText();
        }

        function refreshStreamFrame() {
            if (!streamEnabled || authLocked) return;
            streamFrame.src = `/stream/frame?ts=${Date.now()}`;
        }

        function startFrameTimer() {
            if (streamRefreshTimer) {
                clearInterval(streamRefreshTimer);
            }
            streamRefreshTimer = setInterval(refreshStreamFrame, streamIntervalMs);
        }

        function stopFrameTimer() {
            if (!streamRefreshTimer) return;
            clearInterval(streamRefreshTimer);
            streamRefreshTimer = null;
        }

        function closeNtfyEventSource() {
            if (!ntfyEventSource) return;
            ntfyEventSource.close();
            ntfyEventSource = null;
        }

        function handleUnauthorized(message) {
            stopFrameTimer();
            closeNtfyEventSource();
            setStreamUiState(false, currentStreamMode, selectedWindow, selectedDisplay);
            showAuth(message || 'Session expired. Enter passcode again.');
        }

        async function apiFetch(url, options) {
            const response = await fetch(url, options);
            if (response.status === 401) {
                handleUnauthorized();
                throw new Error('Unauthorized');
            }
            return response;
        }

        function populateWindowSelect(windows, selectedWindowId) {
            windowSelect.innerHTML = '';

            const autoOption = document.createElement('option');
            autoOption.value = '';
            autoOption.textContent = 'Auto (Claude window)';
            windowSelect.appendChild(autoOption);

            windows.forEach((windowInfo) => {
                const option = document.createElement('option');
                option.value = String(windowInfo.id);
                const label = windowInfo.title
                    ? `${windowInfo.appName} — ${windowInfo.title}`
                    : windowInfo.appName;
                option.textContent = `${label} (#${windowInfo.id})`;
                windowSelect.appendChild(option);
            });

            if (selectedWindowId) {
                windowSelect.value = String(selectedWindowId);
            } else {
                windowSelect.value = '';
            }
        }

        function populateDisplaySelect(displays, selectedDisplayId) {
            displaySelect.innerHTML = '';

            const autoOption = document.createElement('option');
            autoOption.value = '';
            autoOption.textContent = 'Auto (All displays)';
            displaySelect.appendChild(autoOption);

            displays.forEach((displayInfo) => {
                const option = document.createElement('option');
                option.value = String(displayInfo.id);
                const mainTag = displayInfo.isMain ? 'Main' : 'Secondary';
                option.textContent = `${mainTag} ${displayInfo.width}x${displayInfo.height} @ (${displayInfo.x}, ${displayInfo.y}) (#${displayInfo.id})`;
                displaySelect.appendChild(option);
            });

            if (selectedDisplayId) {
                displaySelect.value = String(selectedDisplayId);
            } else {
                displaySelect.value = '';
            }
        }

        async function loadWindowOptions() {
            const response = await apiFetch('/stream/windows');
            if (!response.ok) {
                throw new Error('Failed to load windows');
            }

            const payload = await response.json();
            const windows = Array.isArray(payload.windows) ? payload.windows : [];
            const selectedWindowId = payload.selectedWindowId || null;
            noWindowsDetected = windows.length === 0;
            populateWindowSelect(windows, selectedWindowId);

            if (selectedWindowId) {
                selectedWindow = windows.find((item) => item.id === selectedWindowId) || null;
            } else {
                selectedWindow = null;
            }
            updateStreamStatusText();
        }

        async function loadDisplayOptions() {
            const response = await apiFetch('/stream/displays');
            if (!response.ok) {
                throw new Error('Failed to load displays');
            }

            const payload = await response.json();
            const displays = Array.isArray(payload.displays) ? payload.displays : [];
            const selectedDisplayId = payload.selectedDisplayId || null;
            noDisplaysDetected = displays.length === 0;
            populateDisplaySelect(displays, selectedDisplayId);

            if (selectedDisplayId) {
                selectedDisplay = displays.find((item) => item.id === selectedDisplayId) || null;
            } else {
                selectedDisplay = null;
            }
            updateStreamStatusText();
        }

        async function setWindowSelection(windowId) {
            const response = await apiFetch('/stream/select-window', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ windowId })
            });

            if (!response.ok) {
                let message = 'Failed to select window';
                try {
                    const errorPayload = await response.json();
                    if (errorPayload && errorPayload.error) {
                        message = errorPayload.error;
                    }
                } catch {
                    // Ignore JSON parsing error.
                }
                throw new Error(message);
            }

            const payload = await response.json();
            setStreamUiState(
                Boolean(payload.running),
                payload.mode,
                payload.selectedWindow || null,
                payload.selectedDisplay || null
            );
            refreshStreamFrame();
        }

        async function setDisplaySelection(displayId) {
            const response = await apiFetch('/stream/select-display', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ displayId })
            });

            if (!response.ok) {
                let message = 'Failed to select display';
                try {
                    const errorPayload = await response.json();
                    if (errorPayload && errorPayload.error) {
                        message = errorPayload.error;
                    }
                } catch {
                    // Ignore JSON parsing error.
                }
                throw new Error(message);
            }

            const payload = await response.json();
            setStreamUiState(
                Boolean(payload.running),
                payload.mode,
                payload.selectedWindow || null,
                payload.selectedDisplay || null
            );
            refreshStreamFrame();
        }

        async function startStream() {
            const response = await apiFetch('/stream/start', { method: 'POST' });
            if (!response.ok) {
                throw new Error('Failed to start stream');
            }
            const payload = await response.json();
            setStreamUiState(
                true,
                payload.mode,
                payload.selectedWindow || null,
                payload.selectedDisplay || null
            );
            refreshStreamFrame();
            startFrameTimer();
        }

        async function stopStream() {
            const response = await apiFetch('/stream/stop', { method: 'POST' });
            if (!response.ok) {
                throw new Error('Failed to stop stream');
            }
            const payload = await response.json();
            stopFrameTimer();
            setStreamUiState(
                false,
                payload.mode,
                payload.selectedWindow || null,
                payload.selectedDisplay || null
            );
        }

        async function initStreamStatus() {
            const response = await apiFetch('/stream/status');
            if (!response.ok) return;
            const status = await response.json();
            setStreamUiState(
                Boolean(status.running),
                status.mode,
                status.selectedWindow || null,
                status.selectedDisplay || null
            );
            await loadDisplayOptions();
            await loadWindowOptions();
            if (status.running) {
                refreshStreamFrame();
                startFrameTimer();
            }
        }

        function initNtfyEventSource(ntfyTopic) {
            closeNtfyEventSource();
            ntfyEventSource = new EventSource(`https://ntfy.sh/${ntfyTopic}/sse`);
            ntfyEventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.event === 'message' && data.message.includes('responded')) {
                    if (fallbackTimer) {
                        clearTimeout(fallbackTimer);
                    }
                    statusDiv.textContent = "Done — check Claude app";
                    sendBtn.disabled = authLocked;
                }
            };
        }

        async function initAuthenticatedFeatures() {
            const configResponse = await apiFetch('/config');
            if (!configResponse.ok) {
                throw new Error('Unable to load config');
            }
            const config = await configResponse.json();
            doneDelayMs = Number(config.doneDelayMs) || 2000;
            streamIntervalMs = Number(config.streamIntervalMs) || 1000;
            sessionTtlMs = Number(config.accessTtlMs) || sessionTtlMs;
            populateCommandOptions(config.commandOptions);
            setAuthSubtext();
            initNtfyEventSource(config.ntfyTopic);
            await initStreamStatus();
        }

        async function checkAuthStatus() {
            const response = await fetch('/auth/status');
            if (!response.ok) {
                showAuth('Unable to verify access. Try again.');
                return;
            }

            const payload = await response.json();
            sessionTtlMs = Number(payload.sessionTtlMs) || sessionTtlMs;
            setAuthSubtext();

            if (!payload.authenticated) {
                showAuth();
                return;
            }

            hideAuth();
            await initAuthenticatedFeatures();
        }

        async function submitPasscode() {
            const passcode = passcodeInput.value;
            if (!passcode) {
                authError.textContent = 'Passcode is required.';
                return;
            }

            unlockBtn.disabled = true;
            passcodeInput.disabled = true;
            authError.textContent = '';

            try {
                const response = await fetch('/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ passcode })
                });

                if (!response.ok) {
                    let message = 'Invalid passcode.';
                    try {
                        const payload = await response.json();
                        if (payload && payload.error) {
                            message = payload.error;
                        }
                    } catch {
                        // Ignore JSON parse errors.
                    }
                    authError.textContent = message;
                    return;
                }

                const payload = await response.json();
                sessionTtlMs = Number(payload.sessionTtlMs) || sessionTtlMs;
                setAuthSubtext();
                passcodeInput.value = '';
                hideAuth();
                await initAuthenticatedFeatures();
            } catch (error) {
                authError.textContent = 'Login failed. Please try again.';
            } finally {
                unlockBtn.disabled = false;
                passcodeInput.disabled = false;
            }
        }

        toggleStreamBtn.addEventListener('click', async () => {
            toggleStreamBtn.disabled = true;
            try {
                if (streamEnabled) {
                    await stopStream();
                } else {
                    await startStream();
                }
            } catch (error) {
                console.error('Error toggling stream:', error);
                streamStatusDiv.textContent = 'Unable to toggle live view.';
            } finally {
                toggleStreamBtn.disabled = authLocked;
            }
        });

        fullscreenStreamBtn.addEventListener('click', async () => {
            if (fullscreenStreamBtn.disabled) return;
            fullscreenStreamBtn.disabled = true;
            try {
                if (getFullscreenElement()) {
                    await exitStreamFullscreen();
                } else {
                    await enterStreamFullscreen();
                }
                updateFullscreenButtonLabel();
            } catch (error) {
                console.error('Error toggling fullscreen:', error);
                streamStatusDiv.textContent = 'Fullscreen is not supported on this browser.';
            } finally {
                fullscreenStreamBtn.disabled = authLocked || !streamEnabled;
            }
        });

        refreshWindowsBtn.addEventListener('click', async () => {
            refreshWindowsBtn.disabled = true;
            windowSelect.disabled = true;
            try {
                await loadWindowOptions();
            } catch (error) {
                console.error('Error refreshing windows:', error);
                streamStatusDiv.textContent = 'Unable to refresh window list.';
            } finally {
                refreshWindowsBtn.disabled = authLocked;
                windowSelect.disabled = authLocked;
            }
        });

        refreshDisplaysBtn.addEventListener('click', async () => {
            refreshDisplaysBtn.disabled = true;
            displaySelect.disabled = true;
            try {
                await loadDisplayOptions();
            } catch (error) {
                console.error('Error refreshing displays:', error);
                streamStatusDiv.textContent = 'Unable to refresh display list.';
            } finally {
                refreshDisplaysBtn.disabled = authLocked;
                displaySelect.disabled = authLocked;
            }
        });

        windowSelect.addEventListener('change', async () => {
            const rawValue = windowSelect.value;
            const windowId = rawValue ? Number(rawValue) : null;

            windowSelect.disabled = true;
            refreshWindowsBtn.disabled = true;
            try {
                await setWindowSelection(windowId);
            } catch (error) {
                console.error('Error selecting stream window:', error);
                streamStatusDiv.textContent = `Unable to select window: ${error.message}`;
                await loadWindowOptions();
            } finally {
                windowSelect.disabled = authLocked;
                refreshWindowsBtn.disabled = authLocked;
            }
        });

        displaySelect.addEventListener('change', async () => {
            const rawValue = displaySelect.value;
            const displayId = rawValue ? Number(rawValue) : null;

            displaySelect.disabled = true;
            refreshDisplaysBtn.disabled = true;
            try {
                await setDisplaySelection(displayId);
            } catch (error) {
                console.error('Error selecting display:', error);
                streamStatusDiv.textContent = `Unable to select display: ${error.message}`;
                await loadDisplayOptions();
            } finally {
                displaySelect.disabled = authLocked;
                refreshDisplaysBtn.disabled = authLocked;
            }
        });

        document.addEventListener('fullscreenchange', updateFullscreenButtonLabel);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButtonLabel);

        async function submitMessageToClaude(rawMessage, { clearInput = false } = {}) {
            const message = String(rawMessage || '').trim();
            if (!message) return;

            statusDiv.textContent = "Sending...";
            sendBtn.disabled = true;
            sendCommandBtn.disabled = true;

            try {
                const response = await apiFetch('/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });

                if (response.ok) {
                    statusDiv.textContent = "Sent! Waiting for Claude...";
                    if (clearInput) {
                        messageInput.value = '';
                    }
                    if (fallbackTimer) {
                        clearTimeout(fallbackTimer);
                    }
                    fallbackTimer = setTimeout(markDoneFromUiFallback, doneDelayMs + 1500);
                } else {
                    statusDiv.textContent = "Failed to send message.";
                }
            } catch (error) {
                if (error.message !== 'Unauthorized') {
                    console.error("Error sending message:", error);
                    statusDiv.textContent = "Error sending message.";
                }
            } finally {
                sendBtn.disabled = authLocked;
                updateSendCommandState();
            }
        }

        sendBtn.addEventListener('click', async () => {
            const message = messageInput.value.trim();
            await submitMessageToClaude(message, { clearInput: true });
        });

        sendCommandBtn.addEventListener('click', async () => {
            const selectedCommand = commandSelect.value;
            if (!selectedCommand) return;

            const typedMessage = messageInput.value.trim();
            const composedMessage = typedMessage
                ? `${selectedCommand} ${typedMessage}`
                : selectedCommand;
            await submitMessageToClaude(composedMessage, { clearInput: true });
        });

        commandSelect.addEventListener('change', updateSendCommandState);

        unlockBtn.addEventListener('click', submitPasscode);
        passcodeInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                submitPasscode();
            }
        });

        setAuthSubtext();
        showAuth();
        checkAuthStatus().catch((error) => {
            console.error('Auth bootstrap failed:', error);
            showAuth('Unable to verify access. Please try again.');
        });
    </script>
</body>
</html>
